# -*- coding: utf-8 -*-
"""Seguridad en redes inalambricas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Tjf6MsHgzAUtW_WZvF-9pXSD2VseXlb

El ejercicio consiste en crear un programa que pueda detectar y prevenir accesos inalámbricos no autorizados a una red WiFi. Para ello, el programa debe realizar las siguientes tareas:

Escanear el espectro inalámbrico en busca de puntos de acceso (AP) y clientes asociados, utilizando una tarjeta de red compatible con el modo monitor y la inyección de paquetes.
Identificar los AP que pertenecen a la red objetivo, filtrando por el SSID, el canal, la dirección MAC o algún otro criterio.
Identificar los clientes que no pertenecen a la red objetivo, pero que intentan asociarse o autenticarse con los AP, mediante el análisis de las tramas 802.11.
Enviar tramas de desautenticación o desasociación a los clientes no autorizados, para desconectarlos de los AP y evitar que accedan a la red.
Registrar los eventos de detección y prevención en un archivo de texto o una base de datos, indicando la fecha, la hora, el AP, el cliente y el tipo de trama enviada.
Para realizar este ejercicio, se recomienda utilizar alguna de las siguientes librerías o herramientas:

En Python, se puede usar la librería Scapy, que permite crear, enviar y analizar paquetes de red de forma sencilla y flexible. También se puede usar la librería PyRIC, que facilita el manejo de las interfaces de red inalámbricas en Linux.
En C, se puede usar la librería libpcap, que permite capturar y filtrar paquetes de red de forma portable y eficiente. También se puede usar la librería libnet, que permite construir y enviar paquetes de red de forma simple y rápida.
A modo de ejemplo, se muestra un posible código en Python que realiza la tarea de escanear el espectro inalámbrico y mostrar los AP y los clientes encontrados:
"""

# Importar la librería Scapy
from scapy.all import *

# Definir la interfaz de red inalámbrica
iface = "wlan0"

# Definir una lista para almacenar los AP encontrados
aps = []

# Definir una función para procesar los paquetes capturados
def handle_packet(packet):
    # Si el paquete es una trama beacon (anuncio) de un AP
    if packet.haslayer(Dot11Beacon):
        # Obtener el SSID, el canal y la dirección MAC del AP
        ssid = packet[Dot11Elt].info.decode()
        channel = int(ord(packet[Dot11Elt:3].info))
        mac = packet[Dot11].addr2
        # Si el AP no está en la lista, agregarlo y mostrarlo
        if mac not in aps:
            aps.append(mac)
            print(f"AP encontrado: {mac} - {ssid} - Canal {channel}")
    # Si el paquete es una trama de asociación o autenticación de un cliente
    elif packet.haslayer(Dot11AssoReq) or packet.haslayer(Dot11Auth):
        # Obtener la dirección MAC del cliente y del AP
        client = packet[Dot11].addr2
        ap = packet[Dot11].addr1
        # Mostrar el cliente y el AP
        print(f"Cliente encontrado: {client} - AP: {ap}")

# Configurar la interfaz en modo monitor
os.system(f"iwconfig {iface} mode monitor")

# Capturar los paquetes que pasan por la interfaz y llamar a la función handle_packet
sniff(iface=iface, prn=handle_packet)